<#
.SYNOPSIS
Test a list of domains against Qualys SSLLabs security checks. Requires a Chromium browser to run in a headless mode.

Note: This script is a rough draft. Expect edge-case bugs and bad formatting. It needs rewritten for proper logging and better logic.

.PARAMETER Domains
An array of domains to test. Each should be a fully qualified domain name, excluding protocols and trailing characters.

.PARAMETER EmailTo
A valid email address for who to send reports to.

.PARAMETER EmailFrom
An email address to impersonate sending emails from.

.PARAMETER EmailServer
The address of your local mail relay server.

.PARAMETER EmailPort
The port your mail server uses.

.PARAMETER ChromiumPath
The directory of your Chromium instance. Defaults to using Microsoft Edge.

.PARAMETER OutputPath
Where to save transcripts, reports, and archives. Defaults to $env:TEMP\NicScripts\SslLabs_Tests

.PARAMETER NoCache
Enable to avoid retrieving cached reports.

.PARAMETER NoCompress
Enable to avoid compressing reports into a single archive.

.PARAMETER NoLog
Enable to avoid generating log transcripts.

.PARAMETER MaxRetries
How many times to retry retrieving a report. Retries are 30 seconds apart. Defaults to 14, which is approximately 7 minutes.

.PARAMETER PSDataFile
A psd1-formatted data file to pass to the script. This argument was added to assist in splatting arguments while using Task Scheduler.
#>

[CmdletBinding(DefaultParametersetName='None')] 
param (
    [string[]] $Domains,
    
    # Additional email settings will only be required if the EmailTo is supplied, at which point all are required.
    [Parameter(ParameterSetName='Email', Mandatory=$false)]
    [string] $EmailTo = $null,
    [Parameter(ParameterSetName='Email', Mandatory=$true)]
    [string] $EmailFrom,
    [Parameter(ParameterSetName='Email', Mandatory=$true)]
    [string] $EmailServer,
    [Parameter(ParameterSetName='Email', Mandatory=$true)]
    [string] $EmailPort,

    [string] $ChromiumPath = (Join-Path -Path ${env:ProgramFiles(x86)} -ChildPath "Microsoft\Edge\Application\msedge.exe"),
    [string] $OutputPath = [IO.Path]::Combine($env:TEMP, "NicScripts", "SslLabs_Tests"),

    [switch] $NoCache,
    [switch] $NoCompress,
    [switch] $NoLog,
    [int] $MaxRetries = 14,
	
	[string] $PSDataFile = $null
)

if (Test-Path $PSDataFile) {
	$psd1 = Import-PowerShellDataFile $PSDataFile
	foreach ($kvp in $psd1.GetEnumerator()) {
		Set-Variable -Name $kvp.Name -Value $kvp.Value
	}
}

# Define variables
$analyzeUrlTemplate = 'https://www.ssllabs.com/ssltest/analyze.html?d={0}&hideResults=on'
$date = Get-Date -Format "yyyy-MM-dd"
$outputDated = "$OutputPath\$date"
$outputFileTemplate = "$outputDated\{0}.pdf"
$scores = @{}
$rateLimitWaitSeconds = 90

if (-not $NoLog) {
    Start-Transcript -Path "$outputDated\Transcript.log" -IncludeInvocationHeader
}

Write-Verbose "Debug Info:"
Write-Verbose "ChromiumPath: $ChromiumPath"
Write-Verbose "EmailTo: $EmailTo"
Write-Verbose "Use Cache? $NoCache `n"

Write-Output "Verifying directory exists."
# Ensure directory exists
New-Item -ItemType Directory -Path $outputDated -Force -ErrorAction Ignore | Out-Null


# Verify NuGet Package Provider
Write-Output "Verifying NuGet Package Provider..."
if ((Get-PackageProvider -Name NuGet -Force).version -lt 2.8.5.201 ) {
    try {
		Write-Verbose "Installing NuGet Package Provider..."
        Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Confirm:$False -Force -Scope CurrentUser
    }
    catch [Exception]{
		Write-Warning "An error occurred installing NuGet Package Provider!"
        $_.message 
        exit
    }
}
else {
    Write-Verbose "Version of NuGet installed: $((Get-PackageProvider -Name NuGet).version)"
}


Write-Verbose "Verifying PowerHTML..."
# Install PowerHTML on demand
If (-not (Get-Module -ErrorAction Ignore -ListAvailable PowerHTML)) {
    Write-Verbose "Installing PowerHTML module for the current user..."
    Install-Module -Name PowerHTML -Scope CurrentUser -Force -ErrorAction Stop
} else {
	Write-Verbose "PowerHTML already installed...!"
}
Write-Verbose "Importing PowerHTML..."
Import-Module PowerHTML -ErrorAction Stop
Write-Verbose "PowerHTML Imported!"


# Preload the scanning of the pages. Also kicks off a cache clear if requested.
# This is inefficient and allocates memory per scanned URL, but ensures results should be available once we scrape.
Write-Verbose "Starting url preloads..."
foreach ($domain in $Domains) {
    # Attempt to pre-load all URLs with a moderate timeout between.
    $preloadUrl = $analyzeUrlTemplate.Replace('{0}', $domain)

    # Add the flag to clear the cache if needed
    if ($NoCache) {
        $preloadUrl = $preloadUrl + '&clearCache=on'
    }

    Write-Verbose "Preloading url: $preloadUrl"
    try {
        Invoke-WebRequest -Uri $preloadUrl -UseBasicParsing | Out-Null
        Write-Verbose "  Waiting $rateLimitWaitSeconds seconds to avoid rate limiting..."
        Start-Sleep -Seconds $rateLimitWaitSeconds
    } catch {
        Write-Warning "  Failed to preload $domain!"
    }
}


# Iterate domains
foreach ($domain in $Domains) {    
    $analyzeUrl = $analyzeUrlTemplate.Replace('{0}', $domain)
    $outputFile = $outputFileTemplate.Replace('{0}', $domain)
    Write-Verbose "Testing domain: $domain..."
    Write-Verbose "      with url: $analyzeUrl"

    # Wait for page to load
    $retriesCounter = $MaxRetries # 14 tries / 30 seconds = retry for 7 minutes. There's no reason it should take this long unless a server is exceptionally slow.
    $ratingString = ""

    while ( $retriesCounter -gt 0 ) {

        try {
            $wr = Invoke-WebRequest -Uri $analyzeUrl -UseBasicParsing -ErrorAction Stop
            $wrHtml = $wr | ConvertFrom-Html
            $warnBox = $wrHtml.SelectSingleNode('//*[@id="warningBox"]')

            if ($null -eq $warnBox) { # Did not find the warnBox. This indicates we should have a result.
                $ratingBox = $wrHtml.SelectSingleNode('//*[@id="rating"]/div/span')

                # On occasion, it appears some ratingboxes don't contain the span. We need to handle this.
                if ($null -eq $ratingBox) {
                    $ratingBox = $wrHtml.SelectSingleNode('//*[@id="rating"]/div[2]')
                }
                
                # If the ratingbox is still not found, something went wrong.
                if ($null -eq $ratingBox) {
                    Write-Warning "Found neither a warningBox nor a ratingBox!"

                    $submitError = $wrHtml.SelectSingleNode('//*[@id="main"]/div[1]/center/div')
                    if ($null -eq $ratingBox) {
                        Write-Warning "Found a submit error: $($submitError.InnerText.Trim())"
                        $ratingString = $submitError.InnerText.Trim()
                        break
                    }
                    
					break
 
                } else { # Should have a valid result
                    $ratingString = $ratingBox.InnerText.Trim()
                    Write-Output "Found a rating string of '$ratingString'."

                    Write-Verbose "$ChromiumPath --headless --disable-gpu --print-to-pdf=$outputFile $analyzeUrl"
                    & $ChromiumPath --headless --disable-gpu --print-to-pdf=$outputFile $analyzeUrl

                    # Test if the PDF saved properly and log results for transactional purposes.
                    if (-not (Test-Path $outputFile)) {
                        Write-Warning "Failed to detect saved file!"
                    }
                    break
                }

            } else { # Found the warnBox. This should indicate we are not finished loading yet.
                $warningString = $warnBox.InnerText.Trim()

                if ($warningString -inotlike "Please wait.*") {
                    Write-Warning "Warning detected ($domain)- '$warningString'"
                    $ratingString = $warningString
                    break
                }

                Write-Verbose "Waiting for $domain scan to complete ($($MaxRetries - $retriesCounter) / $MaxRetries)..."
                $retriesCounter -= 1
                Start-Sleep 30 # Give the page time to process
            }

        } catch {
            Write-Warning "Invalid Domain - $domain"
            # $Error[0]

            $ratingString = "Invalid Domain - $($Error[0].CategoryInfo.Reason)"                
            break
        }
    }

    $scores += @{ $domain=$ratingString }
}
# Show results in terminal
$scores

# Wait a moment to ensure the Chromium Instance has finished.
Write-Verbose "`n[$(Get-Date -Format {HH:mm:ss})] Pausing for one minute to ensure the headless Chrome instance has finished saving all documents."
Start-Sleep 60
Write-Verbose "`n[$(Get-Date -Format {HH:mm:ss})] Resuming execution.`n"

# Get reference to all the files generated
$attachmentFiles = Get-ChildItem -Path $outputDated -Filter "*.pdf"

# Compress files if needed
if (-not $NoCompress) {
    Write-Output "Compressing PDFs..."

    # Make a zip
    $attachmentFiles | Compress-Archive -DestinationPath "$outputDated\ssllabs_tests.zip" -CompressionLevel Optimal -Force

    # If we've compressed the files, delete the uncompressed ones
    $attachmentFiles | Remove-Item -ErrorAction Ignore

    # Reassign the variable
    $attachmentFiles = "$outputDated\ssllabs_tests.zip"

    Write-Output "Archive saved as $attachmentFiles."
}


if (-not [string]::IsNullOrWhiteSpace($EmailTo)) {
    Write-Output "Sending email report."

    $htmlTemplate = @'
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
{0}
	</head>
	<body>
        <h1>{1}</h1>
		<h2>See attachments for detailed reports on the below domains.</h2>
        <p>Email sent: {3}</p>
        <p>From host: {4}</p>

{2}

	</body>
</html>
'@

    $css = @'
		<style>
            html * {
			    font-family: "Segoe UI", "Segoe UI Web (West European)", "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", sans-serif;
		    }
            
			table, th, td { 
				border: black solid 1px;
				border-collapse: collapse;
			}
			
			td { padding: 2px 25px 2px 10px; }
			
			tr:nth-child(even) { background-color: #AED6F1; }
			tr:nth-child(odd) { background-color: #ABEBC6; }
		</style>
'@

    $scoresHtml = $scores.GetEnumerator() | Select-Object Name, @{Name='Score'; Expression={$_.Value} } | Sort-Object Name | ConvertTo-Html -As Table -Fragment

    $emailSubject = "NicScript - SSLLabs Reports for $(if ($null -ne $date) {$date} else {"{DATE}"})"

    $emailBody = $htmlTemplate -f @(
        $css,
        $emailSubject,
        $($scoresHtml | Out-String),
        "$(Get-Date)",
        $env:COMPUTERNAME
    )
	
	Write-Verbose "From:        $EmailFrom"
	Write-Verbose "To:          $EmailTo"
	Write-Verbose "Server:      $EmailServer"
	Write-Verbose "Port:        $EmailPort"
	Write-Verbose "Title:       $emailSubject"
	Write-Verbose "Body Length: $($emailBody.Length)"
    
    if (-not ($NoCompress) -and -not (Test-Path $attachmentFiles) ) {
        Write-Warning "Failed to validate archive!"
        $attachmentFiles = $null
        $emailBody = "Script failed to attach archived results. Please check $($env:COMPUTERNAME) for transaction logs."
    }

    Send-MailMessage -From $EmailFrom -To $EmailTo -Subject $emailSubject -Body $emailBody -BodyAsHtml -SmtpServer $EmailServer -port $EmailPort -Attachments $attachmentFiles -Priority High
	Write-Warning "Send-MailMessage is insecure and should only be used with an email relay you control and trust. If this is the case, you can ignore this error."
}

if (-not $NoLog) {
    Stop-Transcript
}