<#
.SYNOPSIS
Generated a trimmed report for more easily checking patches against CISA Bulletins.

.DESCRIPTION
A script to scrape a CISA Bulletin (https://www.cisa.gov/news-events/bulletins), parse the output based on a self-generated config file, and output a Word document report.
This project was initially created to simplify the process of assessing vulnerabilities which are applicable to a particular network.

.PARAMETER BulletinUrl
This is a valid URL to a CISA Bulletin

.PARAMETER ConfigPath
A file path pointing to the config.csv file generated by this script. If is does not exist, it will be created.

.PARAMETER OutputPath
A directory path for where you want to save your generated report.

.PARAMETER ConfigsOnly
If true, only updates the config file and skips generating a report.

.PARAMETER OmitAssignments
If true, skips generating an assignments table in the report.
If used with OmitVulnerabilities, it is operationally the same as using the ConfigsOnly switch.

.PARAMETER OmitVulnerabilities
If true, skips generating a vulnerabilities table in the report.
If used with OmitAssignments, it is operationally the same as using the ConfigsOnly switch.

.EXAMPLE
# Generates a report based on a single bulletin
.\Get-CisaReport.ps1 -ConfigPath "$($env:USERPROFILE)Desktop\config.csv" -OutputPath "$($env:USERPROFILE)Desktop\" -BulletinUrl 'https://www.cisa.gov/news-events/bulletins/sb23-338'

.EXAMPLE
# Generates a report based on multiple bulletins
$urls = @(
    'https://www.cisa.gov/news-events/bulletins/sb23-338',
    'https://www.cisa.gov/news-events/bulletins/sb23-331',
    'https://www.cisa.gov/news-events/bulletins/sb23-324'
)

$urls | ForEach-Object { .\Get-CisaReport.ps1 -ConfigPath "$($env:USERPROFILE)Desktop\config.csv" -OutputPath "$($env:USERPROFILE)Desktop\" -BulletinUrl $_ }

.EXAMPLE
# Generates a config file based on multiple bulletins
$urls = @(
    'https://www.cisa.gov/news-events/bulletins/sb23-338',
    'https://www.cisa.gov/news-events/bulletins/sb23-331',
    'https://www.cisa.gov/news-events/bulletins/sb23-324'
)

$urls | ForEach-Object { .\Get-CisaReport.ps1 -ConfigsOnly -ConfigPath "$($env:USERPROFILE)Desktop\config.csv" -OutputPath "$($env:USERPROFILE)Desktop\" -BulletinUrl $_ }
#>

param (
    [string] $BulletinUrl,
    [string] $ConfigPath,
    [string] $OutputPath,
    [switch] $ConfigsOnly,
    [switch] $OmitAssignments,
    [switch] $OmitVulnerabilities
)

#region DEFINE_CLASSES
class ProductEntry {
    [string] $Vendor = 'UNDEFINED'
    [string] $Product = 'UNDEFINED'
    [string] $Assignee = ''
    [boolean] $Ignored = $false
    [string] $Notes = ''
    [DateTime] $AddedOn = (Get-Date).ToString("yyyy/MM/dd hh:mm:ss")

    [string]GetToken() {
        return "$($this.Vendor)~$($this.Product)"
    }

    [string]ToString() {
        return "{$($this.Vendor),$($this.Product),$($this.Assignee),$($this.Ignored)}"
    }
}

class InfoObject {
    [string] $Text
    [string] $Url

    InfoObject($text, $url) {
        $this.Text = $text
        $this.Url = $url
    }

    [string]ToHtml() {
        $sb = [System.Text.StringBuilder]::new()
        $sb.Append('<a href="').Append( ($this.Url) ).Append('" target=”_blank”>')
        $sb.Append( ($this.Text) ).Append('</a>')

        return $sb.ToString()
    }
}

class VulnEntry {
    [string] $Vendor = 'UNDEFINED'
    [string] $Product = 'UNDEFINED'
    [string] $Description = 'UNDEFINED'
    [DateTime] $Published
    [double] $CVSS = -1
    [InfoObject[]] $Info

    [string]GetToken() {
        return "$($this.Vendor)~$($this.Product)"
    }

    [string]GetJoinedInfo() {
        return $($this.Info -join "`r`n" | Out-String)
    }
}
#endregion

#region DEFINE_FUNCTIONS
function ConvertFrom-HTMLTableCustom {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [System.__ComObject] $table
    )
    
    $tableName = $table.summary.Trim()
    Write-Verbose "Processing table [$tableName]"

    $columnName = $table.getElementsByTagName("th") | ForEach-Object { 
        $cText = $_.innerText -replace "^\s*|\s*$" -replace "\r?\n"

        switch ($cText) {
            "PrimaryVendor -- Product" { "Vendor", "Product"; break }
            "CVSS Score" { "CVSS"; break }
            "Source & Patch Info" { "Info"; break }
            default { $cText }
        }
    }

    if ($table.getElementsByTagName("tr")[1].children.length -eq 1) { 
        Write-Warning "Length is shorter than expected for table!"
        Write-Warning "Found message: $($table.getElementsByTagName("tr")[1].innerText)"
    } else {
        $table.getElementsByTagName("tr") | ForEach-Object {
            # read table per row and return object
            $columnValue = $_.getElementsByTagName("td") | ForEach-Object { $_.innerText -replace "^\s*|\s*$" }
            if ($columnValue) {
                $property = [ordered]@{ }
                $i = 0
                $columnName | ForEach-Object {
                    if ($i -lt 2) {
                        try {
                            $split = ($columnValue[0] -split "--").Trim()
                            $property.$_ = $split[$i]
                        } catch {
                            Write-Error "Failed to split line {$columnValue[0]}"
                        }
                    } else {
                        $property.$_ = $columnValue[$i-1]
                    }
                    ++$i
                }
                if ($tableName) {
                    $property.TableName = $tableName
                }

                try {
                    $cvss = [System.Convert]::ToDouble($property.CVSS)
                } catch {
                    $cvss = -1
                }
                $propInfo = ($property.Info -split "`r`n")[0]

                $vuln = [VulnEntry]::new()
                $vuln.Vendor = $property.Vendor
                $vuln.Product = $property.Product
                $vuln.Description = $property.Description
                $vuln.Published = $property.Published
                $vuln.CVSS = $cvss
                $vuln.Info = [InfoObject]::new($propInfo, "https://nvd.nist.gov/vuln/detail/$propInfo")

                return $vuln
            } else {
                # row doesn't contain <td>, its probably row with column names
            }
        }
    }
}
#endregion

#region DEFINE_VARIABLES

#region VALIDATE_CONFIG_PATH
if (-not(Test-Path -Path $ConfigPath -PathType Leaf)) {
    try {
        $null = New-Item -ItemType File -Path $ConfigPath -Force -ErrorAction Stop
        Write-Verbose "The config path does not exist: $ConfigPath"
    } catch {
        throw $_.Exception.Message
        exit 99
    }
}
#endregion

#region VALIDATE_OUTPUT_PATH
if (-not(Test-Path -Path $OutputPath -PathType Container)) {
    try {
        $null = New-Item -ItemType Directory -Path $OutputPath -Force -ErrorAction Stop
        Write-Verbose "The output path does not exist: $OutputPath"
    } catch {
        throw $_.Exception.Message
        exit 99
    }
}
#endregion

$configDirty = $false
$config = [System.Collections.Generic.List[ProductEntry]]::new()
if ($OmitAssignments -and $OmitVulnerabilities) {
    $ConfigsOnly = $true
}
#endregion

#region TRY_LOAD_CONFIG
try {
    $cfg = Import-Csv -Path $ConfigPath -ErrorAction SilentlyContinue

    $cfg | ForEach-Object {
        $c = [ProductEntry]::new()
        $c.Vendor = $_.Vendor
        $c.Product = $_.Product
        $c.Assignee = $_.Assignee
        $c.Ignored = [System.Convert]::ToBoolean( ($_.Ignored) )
        $c.Notes = if ($null -eq $_.Notes) { [string]::Empty } else { $_.Notes }
        
        if ( ($null -ne $_.AddedOn) -and (![String]::IsNullOrWhiteSpace($_.AddedOn)) ) {
            $c.AddedOn = $_.AddedOn
        } else {
            # No date data found. Need to mark dirty to have it be rewritten.
            $configDirty = $true
            $c.AddedOn = Get-Date
        }

        $config.Add($c)
        
        <# DEBUG SECTION #>        
        # Output config as it is read
        # $c | Select-Object Vendor,Product,Assignee,Ignored,Notes,AddedOn
        
        # Output Wildcard entries
        # if ($_.Product -eq '*') { $c | Select-Object Vendor,Product,Assignee,Ignored,Notes,AddedOn }
    }
} catch {
    Write-Warning "Failed loading config file! A new one will be generated based on the current bulletin."
}
#endregion

#region SCRAPE_BULLETIN_DATA
$pageContent = Invoke-WebRequest -Method GET -Uri $BulletinUrl
$allTables = $pageContent.ParsedHtml.getElementsByTagName('table')

$allVulns = $allTables | Foreach-Object { ConvertFrom-HTMLTableCustom $_ -Verbose }
$uniqueProductsList = $allVulns | Select-Object 'Vendor','Product' | Group-Object -Property 'Vendor','Product' | ForEach-Object { $_.Group[0] } | Sort-Object 'Vendor'
#endregion

#region UPDATE_CONFIGS
if ($config.Length -eq 0) {
    "No config was loaded! Generating an new one from the loaded bulletin..."

    $uniqueProductsList | ForEach-Object {
        $c = [ProductEntry]::new()
        $c.Vendor = $_.Vendor
        $c.Product = $_.Product

        $config.Add($c)
    }
} else {
    "Config was loaded! Comparing it against loaded bulletin..."

    $uniqueProductsList | ForEach-Object {
        $uplVendor = $_.Vendor
        $uplProduct = $_.Product
        
        $countFound = ($config | Where-Object { ($_.Vendor -ieq $uplVendor) -and ($_.Product -ieq $uplProduct) }).Length
        if ($countFound -le 0) {
            $c = [ProductEntry]::new()
            $c.Vendor = $_.Vendor
            $c.Product = $_.Product

            "Updating config entry: $($c.ToString())"
            $config.Add($c)
            $configDirty = $true
        }
    }
}

# Write the new config to file
if ($configDirty) {
    "Configuration was updated. Writing changes to disk."

    if (Test-Path $ConfigPath) {
        "Deleting existing file..."
        Remove-Item -Path $ConfigPath -ErrorAction Stop
    }

    "Generating new file with headers..."
    Add-Content -Path $ConfigPath -Value 'Vendor,Product,Assignee,Ignored,Notes,AddedOn'

    "Writing in-memory configuration..."
    $config | Sort-Object Vendor,Product | ForEach-Object {
        $entry = """$($_.Vendor)"",""$($_.Product)"",""$($_.Assignee)"",$($_.Ignored),""$($_.Notes)"",""$($_.AddedOn.ToString("yyyy/MM/dd hh:mm:ss"))"""

        # Vendor,Product,Assignee,Ignored,Notes,AddedOn
        Add-Content -Path $ConfigPath -Value $entry
    }
} else {
    "No changes necessary!"
}

# Bail if only updating configs
if ($ConfigsOnly) {
    "ConfigsOnly switch set. Aborting execution."
    return
}
#endregion

#region PARSE_RELEVANT_ENTRIES
"Parsing Ignored Products..."
$ignoredVendorList = $config | Where-Object {$_.Ignored -eq $true -and $_.Product -eq '*'}
$requiredVendorList = $config | Where-Object {$_.Ignored -eq $false -and $_.Product -eq '*'}
$ignoredProductsList = $config | Where-Object {($_.Vendor -in $ignoredVendorList.Vendor) -or ($_.Ignored -eq $true)}
$ignoredTokens = $ignoredProductsList | ForEach-Object { "$($_.Vendor)~$($_.Product)" }

"Parsing Relevant Vulnerabilities..."
$relevantVulns = $allVulns | Where-Object {($_.Vendor -in $requiredVendorList.Vendor) -or ($_.GetToken() -inotin $ignoredTokens)} | Sort-Object Vendor,Product

"Parsing Unique Relevant Vulnerabilities..."
$uniqueRelevantVulns = $relevantVulns | Group-Object -Property 'Vendor','Product' | ForEach-Object { $_.Group[0] } | Sort-Object 'Vendor'
#endregion

#region GENERATE_WORD_DOC
Write-Verbose "Saving document. This may take some time..."

# Region variables
[ref]$SaveFormat = "microsoft.office.interop.word.WdSaveFormat" -as [type]
$fileName = ($pageContent.ParsedHtml.title.Trim()).Split([IO.Path]::GetInvalidFileNameChars()) -join '_'
$outputPath = "$OutputPath\$fileName.docx"

# Create document for editing
$Word = New-Object -comobject word.application
$Word.Visible = $false
$Doc = $Word.Documents.Add()
$docRange = $Doc.Range()

# Setup page
$Doc.PageSetup.Orientation = [Microsoft.Office.Interop.Word.WdOrientation]::wdOrientLandscape
$Doc.PageSetup.TopMargin    = [float]10
$Doc.PageSetup.BottomMargin = [float]10
$Doc.PageSetup.LeftMargin   = [float]10
$Doc.PageSetup.RightMargin  = [float]10

# Todo: Add header with link

#region _TABLE_FOR_ASSIGNMENTS
if (-not $OmitAssignments) {
    # Create table for all relevant CVEs
    $headers = @("Vendor","Product",<#"CVSS",#> "Assigned","Notes", "Remediation")
    $columns = $headers.Count
    $rows = $uniqueRelevantVulns.Count + 1 # +1 for headers
    $tableAssignments = $Doc.Tables.Add($docRange, $rows, $columns)
    $tableAssignments.Style = "Medium Shading 1 - Accent 5"
    $tableAssignments.AllowAutoFit = 1
    $tableAssignments.Borders.InsideLineStyle = [Microsoft.Office.Interop.Word.WdLineStyle]::wdLineStyleSingle

    # Set table headers
    $h = 1
    $headers | ForEach-Object { $tableAssignments.Cell(1,$h++).Range.Text = $_ }

    # Set row data
    $currentX = 2 # Headers are #1
    foreach ($vuln in $uniqueRelevantVulns) {
        $itemConfig = $config | Where-Object { $_.GetToken() -eq $vuln.GetToken() }

        $y = 1
        $tableAssignments.Cell($currentX, $y++).Range.Text = [string]($vuln.Vendor)
        $tableAssignments.Cell($currentX, $y++).Range.Text = [string]($vuln.Product)

        #$infoRange = $tableAssignments.Cell($currentX, $y++).Range
        #$infoRange.Hyperlinks.Add($infoRange, [string]($vuln.Info[0].Url), $null, $null, [string]($vuln.Info[0].Text)) | Out-Null

        $tableAssignments.Cell($currentX, $y++).Range.Text = [string]($itemConfig.Assignee)
        $tableAssignments.Cell($currentX, $y++).Range.Text = [string]($itemConfig.Notes)
        $tableAssignments.Cell($currentX, $y++).Range.Text = [string]::Empty
        $currentX++
    }

    # Collapse and separate tables
    $docRange.Collapse([Microsoft.Office.Interop.Word.WdCollapseDirection]::wdCollapseEnd)
    $docRange.InsertParagraphAfter()
    $docRange.Collapse([Microsoft.Office.Interop.Word.WdCollapseDirection]::wdCollapseEnd)
}
#endregion



#region _TABLE_FOR_RELEVANT_CVEs
if (-not $OmitVulnerabilities) {
    # Create table for all relevant CVEs
    $headers = @("Vendor","Product","Description","Published","CVSS","Info")
    $columns = $headers.Count
    $rows = $relevantVulns.Count + 1 # +1 for headers
    $tableCVEs = $Doc.Tables.Add($docRange, $rows, $columns)
    $tableCVEs.Style = "Medium Shading 1 - Accent 2"
    $tableCVEs.AllowAutoFit = 1
    $tableCVEs.Borders.InsideLineStyle = [Microsoft.Office.Interop.Word.WdLineStyle]::wdLineStyleSingle

    # Set table headers
    $h = 1
    $headers | ForEach-Object { $tableCVEs.Cell(1,$h++).Range.Text = $_ }

    # Set row data
    $currentX = 2 # Headers are #1
    foreach ($vuln in $relevantVulns) {
        $y = 1
        $tableCVEs.Cell($currentX, $y++).Range.Text = [string]($vuln.Vendor)
        $tableCVEs.Cell($currentX, $y++).Range.Text = [string]($vuln.Product)
        $tableCVEs.Cell($currentX, $y++).Range.Text = [string]($vuln.Description)
        $tableCVEs.Cell($currentX, $y++).Range.Text = [string]($vuln.Published.ToShortDateString())
        $tableCVEs.Cell($currentX, $y++).Range.Text = [string]($vuln.CVSS)
        
        $infoRange = $tableCVEs.Cell($currentX, $y++).Range
        $null = $infoRange.Hyperlinks.Add($infoRange, [string]($vuln.Info[0].Url), $null, $null, [string]($vuln.Info[0].Text))
        $currentX++
    }
}
#endregion

# Save document to file
Write-Verbose "Saving as [$outputPath]..."
$doc.saveas([ref] $outputPath, [ref]$SaveFormat::wdFormatDocumentDefault)

# Cleanup after ourselves
$doc.close()
$word.quit()

[System.Runtime.Interopservices.Marshal]::ReleaseComObject($Doc) | Out-Null
[System.Runtime.Interopservices.Marshal]::ReleaseComObject($Word) | Out-Null
[System.Runtime.Interopservices.Marshal]::ReleaseComObject($docRange) | Out-Null
[System.Runtime.Interopservices.Marshal]::ReleaseComObject($tableAssignments) | Out-Null
[System.Runtime.Interopservices.Marshal]::ReleaseComObject($tableCVEs) | Out-Null
Remove-Variable Doc,Word,docRange,tableAssignments,tableCVEs
[gc]::collect()
[gc]::WaitForPendingFinalizers()
#endregion